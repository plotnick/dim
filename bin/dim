#!/usr/bin/env python
# -*- mode: Python; coding: utf-8 -*-

"""A window manager for the X window system."""

from locale import setlocale, LC_ALL
from os import (close, dup, dup2, execlp, execv, execvp, fork, kill,
                openpty, ttyname, wait)
from termios import tcgetattr, tcsetattr, ECHO, TCSADRAIN
from traceback import print_exception
import os
import pdb
import re
import sys

from xcb.xproto import *

from dim.atom import AtomCache
from dim.bindings import *
from dim.color import RGBi
from dim.daemon import daemon
from dim.decorator import TitlebarConfig, TitlebarDecorator
from dim.event import handler
from dim.ewmh import EWMHManager
from dim.focus import SloppyFocus, ClickToFocus
from dim.keysym import *
from dim.minibuffer import *
from dim.moveresize import MoveResize
from dim.properties import AtomList, WMCommand
from dim.raiselower import RaiseLower
from dim.tags import *
from dim.xutil import *

def print_caption(out=None):
    """You think you're so clever. Well, I'm Dim."""
    if out is None:
        out = sys.stdout
    if out.isatty():
        print >> out, "\033[1mDIM OF THE YARD!\033[m"
    else:
        print >> out, "DIM OF THE YARD!"

def spawn(command):
    """Execute command (a string) in the background via a shell."""
    shell = os.environ.get("SHELL", "/bin/sh")
    if fork():
        return wait()
    daemon(True, True)
    execv(shell, [shell, "-c"] + encode_argv([command]))

def update_tagset(display, spec):
    """Send a tagset specification to a running window manager."""
    conn = xcb.connect(display)
    send_tagset_expr(conn, parse_tagset_spec(spec))
    conn.flush()
    conn.disconnect()

def wm_exit(display, argv=None):
    """Ask a running window manager to exit gracefully, optionally replacing
    it with another command."""
    conn = xcb.connect(display)
    root = conn.get_setup().roots[conn.pref_screen].root
    atoms = AtomCache(conn)

    # We ask the window manager to exit by sending it a _DIM_WM_EXIT
    # client message. If a valid timestamp is provided, the shutdown
    # procedure will exec(3) the command found in the WM_COMMAND property
    # on the root window. Otherwise, it will simply exit.
    if argv is None:
        time = Time.CurrentTime
    else:
        # If the user supplied a command to execute, we'll use it to
        # replace the WM_COMMAND property. Otherwise, we'll just touch it
        # (i.e., perform a zero-length append); since the manager records
        # its original argv on startup, this will cause it to restart.
        mode = PropMode.Replace if argv else PropMode.Append

        # In order to provide a valid timestamp, we need to wait for the
        # corresponding PropertyNotify after we update the property.
        conn.core.ChangeWindowAttributes(root,
                                         CW.EventMask,
                                         [EventMask.PropertyChange])
        conn.core.ChangeProperty(mode, root,
                                 atoms["WM_COMMAND"],
                                 atoms["UTF8_STRING"],
                                 *WMCommand(argv).change_property_args())
        while True:
            conn.flush()
            event = conn.wait_for_event()
            if (isinstance(event, PropertyNotifyEvent) and
                event.window == root and
                event.atom == atoms["WM_COMMAND"]):
                time = event.time
                break
    send_client_message(conn, root, False,
                        EventMask.SubstructureRedirect,
                        root, atoms["_DIM_WM_EXIT"],
                        32, [time, 0, 0, 0, 0])
    conn.flush()
    conn.disconnect()

class EmergencyTTY(object):
    """Attach to a terminal for emergency debugging. If we're already running
    in a terminal, we'll just use that; otherwise, we'll launch a new xterm(1)
    in slave mode and attach to it."""

    def __new__(cls, *args, **kwargs):
        if sys.stdin.isatty() and sys.stdout.isatty():
            cls = TrivialTTY
        return super(EmergencyTTY, cls).__new__(cls, *args, **kwargs)

    def __init__(self):
        # Save the current values of stdin & stdout; we'll restore them on
        # close. We'll leave stderr alone, since presumably it's redirected
        # somewhere for logging.
        self.stdin = dup(sys.stdin.fileno())
        self.stdout = dup(sys.stdout.fileno())

        master, slave = openpty()

        # When xterm is started in slave mode, it immediately writes its
        # X window id to the tty. We don't want that displayed to the user,
        # so we'll temporarily disable echo, then re-enable it below.
        orig_attr = tcgetattr(master)
        temp_attr = orig_attr[:]
        temp_attr[3] &= ~ECHO # lflags
        tcsetattr(master, TCSADRAIN, temp_attr)

        if not fork():
            close(slave)
            daemon()
            execlp("xterm", "xterm",
                   "-name", "dim",
                   "-geometry", "-0-0",
                   "-S%s/%d" % (ttyname(master), master))
        else:
            dup2(slave, sys.stdin.fileno())
            dup2(slave, sys.stdout.fileno())
            if slave > 2:
                close(slave)
            windowid = int(sys.stdin.readline(), 16)
            log.info("Attaching to xterm 0x%x on %s.",
                     windowid, ttyname(master))
            tcsetattr(master, TCSADRAIN, orig_attr)
            close(master)
            wait()

    def close(self):
        # Closing the fds attached to the tty should cause the xterm to die,
        # so we don't need to explicitly kill it.
        dup2(self.stdin, sys.stdin.fileno())
        dup2(self.stdout, sys.stdout.fileno())
        close(self.stdin)
        close(self.stdout)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

class TrivialTTY(EmergencyTTY):
    def __init__(self):
        pass

    def close(self):
        pass

class BaseWM(EWMHManager, TagManager, MoveResize, RaiseLower):
    default_decorator_class = TitlebarDecorator

    def __init__(self,
                 titlebar_bindings={},
                 title_font="fixed",
                 minibuffer_font="10x20",
                 **kwargs):
        self.titlebar_bindings = titlebar_bindings
        self.title_font = title_font
        self.minibuffer_font = minibuffer_font
        super(BaseWM, self).__init__(**kwargs)

    def init_graphics(self):
        super(BaseWM, self).init_graphics()

        bindings = self.titlebar_bindings
        self.focused_config = TitlebarConfig(self,
                                             fg_color=RGBi(1.0, 1.0, 1.0),
                                             bg_color=RGBi(0.0, 0.0, 0.0),
                                             font=self.title_font,
                                             button_bindings=bindings)
        self.unfocused_config = TitlebarConfig(self,
                                               fg_color=RGBi(0.0, 0.0, 0.0),
                                               bg_color=RGBi(0.75, 0.75, 0.75),
                                               font=self.title_font,
                                               button_bindings=bindings)

        self.minibuffer_config = MinibufferConfig(self,
                                                  fg_color=RGBi(0.0, 0.0, 0.0),
                                                  bg_color=RGBi(1.0, 1.0, 1.0),
                                                  font=self.minibuffer_font)

    def make_decorator(self, cls, client, **kwargs):
        return cls(self.conn, client,
                   focused_config=self.focused_config,
                   unfocused_config=self.unfocused_config,
                   **kwargs)

    @staticmethod
    @event_mask(MoveResize.move_window.event_mask)
    def raise_and_move(widget, event):
        manager = widget.manager
        manager.raise_window(event)
        manager.move_window(event, move_delta=5)

    @staticmethod
    def change_tags(widget, event):
        client = widget.client
        def intern_atom(name):
            return client.atoms[name.encode("UTF-8", "replace")]
        def atom_name(atom):
            return client.atoms.name(atom, "UTF-8", "replace")
        def set_tags(tag_names):
            # Tag names are separated by whitespace and/or commas.
            tag_names = tag_names.replace(",", " ").split()
            client.dim_tags = AtomList(map(intern_atom, tag_names))
        tag_names = [atom_name(tag) for tag in client.dim_tags]
        client.decorator.read_from_user("Tags: ", " ".join(tag_names),
                                        set_tags, time=event.time)

    def shell_command(self, event):
        def execute(command):
            spawn(command)
            dismiss()
        def dismiss():
            minibuffer.destroy()
        minibuffer = Minibuffer(manager=self,
                                parent=self.screen.root,
                                config=self.minibuffer_config,
                                prompt="Shell command: ",
                                commit=execute,
                                rollback=dismiss)
        minibuffer.map(event.time)

    def change_tagset(self, event):
        def execute(spec):
            try:
                expr = parse_tagset_spec(spec)
            except SpecSyntaxError as err:
                log.warning("Syntax error in tagset specification '%s': %s.",
                            spec, err.args[0])
            else:
                send_tagset_expr(self.conn, expr,
                                 screen=self.screen_number,
                                 atoms=self.atoms)
            dismiss()
        def dismiss():
            minibuffer.destroy()
        minibuffer = Minibuffer(manager=self,
                                parent=self.screen.root,
                                config=self.minibuffer_config,
                                prompt="Tagset: ",
                                commit=execute,
                                rollback=dismiss)
        minibuffer.map(event.time)

    def delete_window(self, event):
        client = self.current_focus
        if client:
            client.delete(event.time)
        else:
            log.warning("Can't get current input focus.")

    def debug(self, event):
        self.conn.core.SetInputFocusChecked(InputFocus.PointerRoot,
                                            InputFocus.PointerRoot,
                                            event.time).check()
        with mask_events(self.conn, self.screen.root,
                         self.root_event_mask,
                         EventMask.SubstructureRedirect,
                         checked=True):
            with EmergencyTTY():
                print_caption()
                print u"""\a
This is a debugging console running the Python debugger (pdb). Type ‘help’
for a list of pdb commands, or ‘continue’ to resume normal operations.

Dim is currently suspended. It is not processing events, and has temporarily
de-selected SubstructureRedirect on the root window. The ‘self’ variable
contains the current window manager instance, which you may use to examine
and modify (carefully, please!) internal data structures.
"""
                pdb.set_trace()
                pass
        self.ensure_focus()

    def activate_screen_saver(self, event):
        # This function must be bound to a release event, since otherwise,
        # the corresponding release event will immediately wake up the
        # server.
        assert isinstance(event, (KeyReleaseEvent, ButtonReleaseEvent))
        self.conn.core.ForceScreenSaverChecked(ScreenSaver.Active).check()

    def terminal(self, event):
        spawn("xterm")

titlebar_button_bindings = {
    1: BaseWM.raise_and_move,
    2: BaseWM.change_tags
}

global_key_bindings = {
    ("control", "meta", XK_Return): BaseWM.terminal,
    ("control", "meta", XK_Tab): BaseWM.change_tagset,
    ("control", "meta", XK_Escape): BaseWM.delete_window,
    ("control", "meta", XK_space): BaseWM.shell_command,
    ("control", XK_Pause): BaseWM.debug,
    -XK_Pause: BaseWM.activate_screen_saver
}

global_button_bindings = {
    ("meta", 1): MoveResize.move_window,
    ("meta", 3): MoveResize.resize_window,
    ("shift", "meta", 1): RaiseLower.raise_window,
    ("shift", "meta", 3): RaiseLower.lower_window
}

if __name__ == "__main__":
    from optparse import OptionGroup, OptionParser, OptionValueError
    import logging
    import os
    import xcb

    # Initialize locale.
    setlocale(LC_ALL, "")

    # Execute user code.
    try:
        execfile(os.path.expanduser("~/.dim.py"))
    except IOError:
        pass

    # Parse command-line options.
    focus_modes = {"sloppy": SloppyFocus, "click": ClickToFocus}
    def consume_remaining_args(option, opt_str, value, parser):
        value = parser.rargs[:]
        del parser.rargs[:]
        setattr(parser.values, option.dest, value)

    optparser = OptionParser("Usage: %prog [OPTIONS] [-e COMMAND [ARG ...]]")
    optparser.set_defaults(focus_mode="sloppy",
                           title_font="fixed",
                           minibuffer_font="10x20")
    optparser.add_option("--version",
                         action="store_true", dest="version",
                         help="output version information and exit")
    optparser.add_option("--display",
                         dest="display",
                         help="the X server display name")
    optparser.add_option("--focus-mode",
                         dest="focus_mode",
                         type="choice", choices=focus_modes.keys(),
                         metavar="MODE",
                         help=(("focus mode: one of %s "
                                % ", ".join(map(str, focus_modes.keys()))) +
                               "(default: %default)"))
    optparser.add_option("--title-font",
                         dest="title_font",
                         metavar="FONT",
                         help="client window title font (default: %default)")
    optparser.add_option("--minibuffer-font",
                         dest="minibuffer_font",
                         metavar="FONT",
                         help="minibuffer font (default: %default)")

    control = optparser.add_option_group("Control Options")
    control.add_option("-t", "--tagset",
                       dest="tagset_spec",
                       metavar="SPEC",
                       help="switch to the specified tagset")
    control.add_option("-e", "--exec",
                       action="callback", callback=consume_remaining_args,
                       dest="command",
                       help="execute another window manager command; "
                            "must be the last option provided")
    control.add_option("-r", "--restart",
                       action="store_const", dest="command", const=[],
                       help="restart a running window manager")
    control.add_option("-x", "--exit",
                       action="store_true", dest="exit",
                       help="ask a running window manager to exit gracefully")

    debugging = optparser.add_option_group("Debugging Options")
    debugging.add_option("-d", "--debug",
                         action="store_true", dest="debug",
                         help="show debugging messages")
    debugging.add_option("-v", "--verbose",
                         action="store_true", dest="verbose",
                         help="be prolix, loquacious, and multiloquent")
    debugging.add_option("-l", "--log",
                         action="append", dest="log",
                         metavar="MODULE",
                         help="enable logging for the specified module")

    (options, args) = optparser.parse_args()
    if options.version:
        print_caption()
        print "Version 0.1"
        sys.exit(0)
    elif options.tagset_spec:
        update_tagset(options.display, *decode_argv([options.tagset_spec]))
        sys.exit(0)
    elif options.exit:
        wm_exit(options.display)
        sys.exit(0)
    elif options.command is not None:
        wm_exit(options.display, decode_argv(options.command))
        sys.exit(0)

    # Put the display in the environment for the benefit of our children.
    if options.display:
        os.environ["DISPLAY"] = options.display

    # Initialize logging system.
    tty = logging.StreamHandler(sys.stderr)
    tty.setFormatter(logging.Formatter("%(levelname)s: %(name)s: %(message)s"))
    logging.getLogger("").addHandler(tty)
    log_level = (logging.DEBUG if options.debug else
                 logging.INFO if options.verbose else
                 logging.WARNING)
    for name in ([""] if options.log is None or "*" in options.log
                 else options.log):
        logging.getLogger(name).setLevel(log_level)
    log = logging.getLogger("wm")

    # Construct a window manager class by mixing in the selected focus policy.
    log.debug("Using %s focus policy.", options.focus_mode)
    wm_class = type("WM", (focus_modes[options.focus_mode], BaseWM), {})

    # Instantiate the window manager and start it up.
    wm = wm_class(display=options.display,
                  key_bindings=global_key_bindings,
                  button_bindings=global_button_bindings,
                  titlebar_bindings=titlebar_button_bindings,
                  title_font=options.title_font,
                  minibuffer_font=options.minibuffer_font)
    try:
        wm.start()
    except KeyboardInterrupt:
        wm.shutdown()
    except Exception:
        exc_type, exc_value, traceback = sys.exc_info()
        if not sys.stderr.isatty():
            print_exception(exc_type, exc_value, traceback, file=sys.stderr)
        try:
            wm.shutdown()
        except Exception:
            pass
        with EmergencyTTY():
            print_caption()
            print u"""\a
Dim has caught a fatal exception, and has shut down as cleanly it can.
This console is for post-mortem debugging only. Type ‘help' for a list
of pdb commands, ‘run’ to restart, or ‘quit’ to abort.

The window manager instance is in the ‘wm’ variable, and the exception
that delivered the fatal blow is in the ‘exc_value’ variable.
"""
            print_exception(exc_type, exc_value, traceback, file=sys.stdout)
            try:
                pdb.post_mortem(traceback)
            except pdb.Restart:
                log.info("Restarting: %s", " ".join(sys.argv))
                execvp(sys.argv[0], sys.argv)
