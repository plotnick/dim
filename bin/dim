#!/usr/bin/env python
# -*- mode: Python; coding: utf-8 -*-

"""A window manager for the X window system."""

from collections import deque
from locale import getpreferredencoding, setlocale, LC_ALL
from os import (close, dup, dup2, execlp, execv, fork, kill,
                openpty, ttyname, wait)
from termios import tcgetattr, tcsetattr, ECHO, TCSADRAIN
from traceback import print_exception
import pdb
import re
import sys

from xcb.xproto import *

from dim.atom import AtomCache
from dim.bindings import *
from dim.color import RGBi
from dim.daemon import daemon
from dim.decorator import TitlebarConfig, TitlebarDecorator
from dim.event import handler
from dim.focus import SloppyFocus, ClickToFocus
from dim.keysym import *
from dim.minibuffer import *
from dim.moveresize import MoveResize
from dim.properties import AtomList
from dim.raiselower import RaiseLower
from dim.tags import *
from dim.xutil import *

def print_caption(out=None):
    """You think you're so clever. Well, I'm Dim."""
    if out is None:
        out = sys.stdout
    if out.isatty():
        print >> out, "\033[1mDIM OF THE YARD!\033[m"
    else:
        print >> out, "DIM OF THE YARD!"

def spawn(command):
    """Execute command (a string) in the background via a shell."""
    if fork():
        return wait()
    daemon(True, True)
    execv("/bin/sh",
          ["/bin/sh", "-c",
           command.encode(getpreferredencoding(False), "backslashreplace")])

def update_tagset(display, spec):
    """Send a tagset specification to a running window manager."""
    conn = xcb.connect(display)
    send_tagset_expr(conn, parse_tagset_spec(spec))
    conn.flush()
    conn.disconnect()

def wm_exit(display):
    """Ask a running window manager to exit gracefully."""
    conn = xcb.connect(display)
    root = conn.get_setup().roots[conn.pref_screen].root
    atoms = AtomCache(conn)
    send_client_message(conn, root, False,
                        EventMask.StructureNotify,
                        root, atoms["_DIM_WM_EXIT"],
                        32, [0] * 5)
    conn.flush()
    conn.disconnect()

class EmergencyTTY(object):
    """Attach to a terminal for emergency debugging. If we're already running
    in a terminal, we'll just use that; otherwise, we'll launch a new xterm(1)
    in slave mode and attach to it."""

    def __new__(cls, *args, **kwargs):
        if sys.stdin.isatty() and sys.stdout.isatty():
            cls = TrivialTTY
        return super(EmergencyTTY, cls).__new__(cls, *args, **kwargs)

    def __init__(self):
        # Save the current values of stdin & stdout; we'll restore them on
        # close. We'll leave stderr alone, since presumably it's redirected
        # somewhere for logging.
        self.stdin = dup(sys.stdin.fileno())
        self.stdout = dup(sys.stdout.fileno())

        master, slave = openpty()

        # When xterm is started in slave mode, it immediately writes its
        # X window id to the tty. We don't want that displayed to the user,
        # so we'll temporarily disable echo, then re-enable it below.
        orig_attr = tcgetattr(master)
        temp_attr = orig_attr[:]
        temp_attr[3] &= ~ECHO # lflags
        tcsetattr(master, TCSADRAIN, temp_attr)

        if not fork():
            close(slave)
            daemon()
            execlp("xterm", "xterm",
                   "-name", "dim",
                   "-geometry", "-0-0",
                   "-S%s/%d" % (ttyname(master), master))
        else:
            dup2(slave, sys.stdin.fileno())
            dup2(slave, sys.stdout.fileno())
            if slave > 2:
                close(slave)
            windowid = int(sys.stdin.readline(), 16)
            log.info("Attaching to xterm 0x%x on %s.",
                     windowid, ttyname(master))
            tcsetattr(master, TCSADRAIN, orig_attr)
            close(master)
            wait()

    def close(self):
        # Closing the fds attached to the tty should cause the xterm to die,
        # so we don't need to explicitly kill it.
        dup2(self.stdin, sys.stdin.fileno())
        dup2(self.stdout, sys.stdout.fileno())
        close(self.stdin)
        close(self.stdout)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

class TrivialTTY(EmergencyTTY):
    def __init__(self):
        pass

    def close(self):
        pass

class BaseWM(TagManager, MoveResize, RaiseLower):
    def __init__(self,
                 titlebar_bindings={},
                 title_font="fixed",
                 minibuffer_font="10x20",
                 **kwargs):
        self.titlebar_bindings = titlebar_bindings
        self.title_font = title_font
        self.minibuffer_font = minibuffer_font
        super(BaseWM, self).__init__(**kwargs)

    def init_graphics(self):
        super(BaseWM, self).init_graphics()

        bindings = self.titlebar_bindings
        self.focused_config = TitlebarConfig(self,
                                             fg_color=RGBi(1.0, 1.0, 1.0),
                                             bg_color=RGBi(0.0, 0.0, 0.0),
                                             font=self.title_font,
                                             button_bindings=bindings)
        self.unfocused_config = TitlebarConfig(self,
                                               fg_color=RGBi(0.0, 0.0, 0.0),
                                               bg_color=RGBi(0.75, 0.75, 0.75),
                                               font=self.title_font,
                                               button_bindings=bindings)

        self.minibuffer_config = MinibufferConfig(self,
                                                  fg_color=RGBi(0.0, 0.0, 0.0),
                                                  bg_color=RGBi(1.0, 1.0, 1.0),
                                                  font=self.minibuffer_font)

    def decorator(self, client):
        return TitlebarDecorator(self.conn, client,
                                 focused_config=self.focused_config,
                                 unfocused_config=self.unfocused_config)

    @staticmethod
    @event_mask(MoveResize.move_window.event_mask)
    def raise_and_move(widget, event):
        manager = widget.manager
        manager.raise_window(event)
        manager.move_window(event, move_delta=5)

    @staticmethod
    def change_tags(widget, event):
        client = widget.client
        def intern_atom(name):
            return client.atoms[name.encode("UTF-8", "replace")]
        def atom_name(atom):
            return client.atoms.name(atom, "UTF-8", "replace")
        def set_tags(tag_names):
            # Tag names are separated by whitespace and/or commas.
            tag_names = tag_names.replace(",", " ").split()
            client.properties.dim_tags = AtomList(map(intern_atom, tag_names))
        tag_names = [atom_name(tag) for tag in client.properties.dim_tags]
        client.decorator.read_from_user("Tags: ", " ".join(tag_names),
                                        set_tags, time=event.time)

    def shell_command(self, event):
        def execute(command):
            spawn(command)
            dismiss()
        def dismiss():
            minibuffer.destroy()
        minibuffer = Minibuffer(manager=self,
                                parent=self.screen.root,
                                config=self.minibuffer_config,
                                prompt="Shell command: ",
                                commit=execute,
                                rollback=dismiss)
        minibuffer.map(event.time)

    def change_tagset(self, event):
        def execute(spec):
            try:
                expr = parse_tagset_spec(spec)
            except SpecSyntaxError as err:
                log.warning("Syntax error in tagset specification '%s': %s.",
                            spec, err.args[0])
            else:
                send_tagset_expr(self.conn, expr,
                                 screen=self.screen_number,
                                 atoms=self.atoms)
            dismiss()
        def dismiss():
            minibuffer.destroy()
        minibuffer = Minibuffer(manager=self,
                                parent=self.screen.root,
                                config=self.minibuffer_config,
                                prompt="Tagset: ",
                                commit=execute,
                                rollback=dismiss)
        minibuffer.map(event.time)

    def delete_window(self, event):
        client = self.current_focus
        if client:
            client.delete(event.time)
        else:
            log.warning("Can't get current input focus.")

    def debug(self, event):
        self.conn.core.SetInputFocusChecked(InputFocus.PointerRoot,
                                            InputFocus.PointerRoot,
                                            event.time).check()
        with mask_events(self.conn, self.screen.root,
                         self.root_event_mask,
                         EventMask.SubstructureRedirect,
                         checked=True):
            with EmergencyTTY():
                print_caption()
                print u"""\a
This is a debugging console running the Python debugger (pdb). Type ‘help’
for a list of pdb commands, or ‘continue’ to resume normal operations.

Dim is currently suspended. It is not processing events, and has temporarily
de-selected SubstructureRedirect on the root window. The ‘self’ variable
contains the current window manager instance, which you may use to examine
and modify (carefully, please!) internal data structures.
"""
                pdb.set_trace()
                pass
        self.ensure_focus()

    def activate_screen_saver(self, event):
        # This function must be bound to a release event, since otherwise,
        # the corresponding release event will immediately wake up the
        # server.
        assert isinstance(event, (KeyReleaseEvent, ButtonReleaseEvent))
        self.conn.core.ForceScreenSaverChecked(ScreenSaver.Active).check()

    def terminal(self, event):
        spawn("xterm")

titlebar_button_bindings = {
    1: BaseWM.raise_and_move,
    2: BaseWM.change_tags
}

global_key_bindings = {
    ("control", "meta", XK_Return): BaseWM.terminal,
    ("control", "meta", XK_Tab): BaseWM.change_tagset,
    ("control", "meta", XK_Escape): BaseWM.delete_window,
    ("control", "meta", XK_space): BaseWM.shell_command,
    ("control", XK_Pause): BaseWM.debug,
    -XK_Pause: BaseWM.activate_screen_saver
}

global_button_bindings = {
    ("meta", 1): MoveResize.move_window,
    ("meta", 3): MoveResize.resize_window,
    ("shift", "meta", 1): RaiseLower.raise_window,
    ("shift", "meta", 3): RaiseLower.lower_window
}

if __name__ == "__main__":
    from optparse import OptionParser
    import logging
    import os
    import xcb

    # Initialize locale.
    setlocale(LC_ALL, "")

    # Parse command-line options.
    focus_modes = {"sloppy": SloppyFocus, "click": ClickToFocus}
    optparser = OptionParser("Usage: %prog [OPTIONS]")
    optparser.add_option("-D", "--debug", action="store_true", dest="debug",
                         help="show debugging messages")
    optparser.add_option("-L", "--log", action="append", dest="log",
                         help="enable logging for the specified module")
    optparser.add_option("-V", "--verbose", action="store_true", dest="verbose",
                         help="be prolix, loquacious, and multiloquent")
    optparser.add_option("-d", "--display", dest="display",
                         help="the X server display name")
    optparser.add_option("-f", "--focus-mode", dest="focus_mode",
                         type="choice", choices=focus_modes.keys(),
                         default="sloppy",
                         help="focus mode: sloppy or click")
    optparser.add_option("-s", "--tagset", dest="tagset_spec",
                         help="specify a tagset expression")
    optparser.add_option("-t", "--title-font", dest="title_font",
                         default="fixed",
                         help="client window title font")
    optparser.add_option("-m", "--minibuffer-font", dest="minibuffer_font",
                         default="10x20",
                         help="window manager minibuffer font")
    optparser.add_option("-v", "--version", action="store_true", dest="version",
                         help="output version information and exit")
    optparser.add_option("-x", "--exit", action="store_true", dest="exit",
                         help="ask running window manager to exit gracefully")
    (options, args) = optparser.parse_args()
    if options.version:
        print_caption()
        print "Version 0.1"
        sys.exit(0)
    elif options.tagset_spec:
        update_tagset(options.display,
                      unicode(options.tagset_spec,
                              getpreferredencoding(False)))
        sys.exit(0)
    elif options.exit:
        wm_exit(options.display)
        sys.exit(0)

    # Put the display in the environment for the benefit of our children.
    if options.display:
        os.environ["DISPLAY"] = options.display

    # Initialize logging system.
    tty = logging.StreamHandler(sys.stderr)
    tty.setFormatter(logging.Formatter("%(levelname)s: %(name)s: %(message)s"))
    logging.getLogger("").addHandler(tty)
    log_level = (logging.DEBUG if options.debug else
                 logging.INFO if options.verbose else
                 logging.WARNING)
    for name in ([""] if options.log is None or "*" in options.log
                 else options.log):
        logging.getLogger(name).setLevel(log_level)
    log = logging.getLogger("wm")

    # Construct a window manager class by mixing in the selected focus policy.
    log.debug("Using %s focus policy.", options.focus_mode)
    wm_class = type("WM", (focus_modes[options.focus_mode], BaseWM), {})

    # Instantiate the window manager and start it up.
    wm = wm_class(display=options.display,
                  key_bindings=global_key_bindings,
                  button_bindings=global_button_bindings,
                  titlebar_bindings=titlebar_button_bindings,
                  title_font=options.title_font,
                  minibuffer_font=options.minibuffer_font)
    try:
        wm.start()
    except KeyboardInterrupt:
        log.info("Interrupt caught; shutting down.")
        wm.shutdown()
    except Exception:
        exc_type, exc_value, traceback = sys.exc_info()
        if not sys.stderr.isatty():
            print_exception(exc_type, exc_value, traceback, file=sys.stderr)
        try:
            wm.shutdown()
        except Exception:
            pass
        with EmergencyTTY():
            print_caption()
            print u"""\a
Dim has caught a fatal exception, and has shut down as cleanly it can.
This console is for post-mortem debugging only. Type ‘help' for a list
of pdb commands, or ‘quit’ to abort.

The window manager instance is in the ‘wm’ variable, and the exception
that delivered the fatal blow is in the ‘exc_value’ variable.
"""
            print_exception(exc_type, exc_value, traceback, file=sys.stdout)
            pdb.post_mortem(traceback)
